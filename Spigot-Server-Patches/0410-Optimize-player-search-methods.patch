From 3a1f3c47a1144b605d06169dd754516a678b4ca6 Mon Sep 17 00:00:00 2001
From: egg82 <eggys82@gmail.com>
Date: Sat, 10 Aug 2019 13:35:03 -0600
Subject: [PATCH] Optimize player search methods

This patch optimizes world searches for players, and hooks methods
that can be optimized further in future patches.

In regards to open issues, it should close #1289

The optimizations are as follows:
  1. Short-circuit edge cases
  2. Optimize methods in general
  3. Utilize getEntities method which can be optimized in future patches

diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index c950139c0..ba0d175ba 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -206,6 +206,7 @@ public class AxisAlignedBB {
         return this.e(vec3d.x, vec3d.y, vec3d.z);
     }
 
+    public final boolean contains(double d0, double d1, double d2) { return e(d0, d1, d2); } // Paper - OBFHELPER
     public boolean e(double d0, double d1, double d2) {
         return d0 >= this.minX && d0 < this.maxX && d1 >= this.minY && d1 < this.maxY && d2 >= this.minZ && d2 < this.maxZ;
     }
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index e8def7f81..0c782d5f5 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1391,6 +1391,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return MathHelper.c(f * f + f1 * f1 + f2 * f2);
     }
 
+    public double getDistanceSquared(double centerX, double centerY, double centerZ) { return e(centerX, centerY, centerZ); } // Paper - OBFHELPER
     public double e(double d0, double d1, double d2) {
         double d3 = this.locX - d0;
         double d4 = this.locY - d1;
diff --git a/src/main/java/net/minecraft/server/IEntityAccess.java b/src/main/java/net/minecraft/server/IEntityAccess.java
index dca18afdb..fc66469e5 100644
--- a/src/main/java/net/minecraft/server/IEntityAccess.java
+++ b/src/main/java/net/minecraft/server/IEntityAccess.java
@@ -1,11 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -60,7 +56,49 @@ public interface IEntityAccess {
     }
 
     @Nullable
-    default EntityHuman a(double d0, double d1, double d2, double d3, @Nullable Predicate<Entity> predicate) {
+    // Paper start - optimize method
+    default EntityHuman a(double centerX, double centerY, double centerZ, double searchRadius, @Nullable Predicate<Entity> predicate) {
+        List<? extends Entity> foundEntities = searchRadius < 0.0d ? getAllPlayers(predicate)
+            : getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                centerY - searchRadius,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                centerY + searchRadius,
+                centerZ + searchRadius
+            ),
+            predicate
+        );
+        if (foundEntities.isEmpty()) {
+            return null;
+        }
+
+        EntityHuman retVal = null;
+        double minDistance = Double.MAX_VALUE;
+        double searchRadiusSquared = searchRadius * searchRadius;
+
+        for (Entity entity : foundEntities) {
+            if (!(entity instanceof EntityHuman) || entity.dead) { // Paper - don't pull dead players
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, centerY, centerZ);
+            if (searchRadius >= 0.0d && distance >= searchRadiusSquared) {
+                // With searchRadius >= 0.0d:
+                //   pulling player closest to x, y, z regardless of distance when searchRadius < 0, in keeping with previous behavior
+                // With distance >= searchRadiusSquared:
+                //   getEntities is a cube. We want a sphere, so double-check distance.
+                continue;
+            }
+            minDistance = Math.min(minDistance, distance);
+            if (distance == minDistance) {
+                retVal = (EntityHuman) entity;
+            }
+        }
+
+        return retVal;
+    }
+    /*default EntityHuman a(double d0, double d1, double d2, double d3, @Nullable Predicate<Entity> predicate) {
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
         Iterator iterator = this.getPlayers().iterator();
@@ -79,7 +117,16 @@ public interface IEntityAccess {
         }
 
         return entityhuman;
+    }*/
+
+    default List<EntityHuman> getAllPlayers(@Nullable Predicate<? super Entity> predicate) {
+        List<EntityHuman> retVal = new ArrayList<>(this.getPlayers());
+        if (predicate != null) {
+            retVal.removeIf(predicate);
+        }
+        return retVal;
     }
+    // Paper end
 
     @Nullable
     default EntityHuman findNearbyPlayer(Entity entity, double d0) {
@@ -94,7 +141,49 @@ public interface IEntityAccess {
     }
 
     @Nullable
-    default EntityHuman a(double d0, double d1, double d2) {
+    // Paper start - optimize methods
+    default EntityHuman a(double centerX, double centerZ, double searchRadius) {
+        List<? extends Entity> foundEntities = searchRadius < 0.0d ? getAllPlayers(IEntitySelector.notSpectator())
+            : getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                Double.MIN_VALUE,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                Double.MAX_VALUE,
+                centerZ + searchRadius
+            ),
+            IEntitySelector.notSpectator()
+        );
+        if (foundEntities.isEmpty()) {
+            return null;
+        }
+
+        EntityHuman retVal = null;
+        double minDistance = Double.MAX_VALUE;
+        double searchRadiusSquared = searchRadius * searchRadius;
+
+        for (Entity entity : foundEntities) {
+            if (!(entity instanceof EntityHuman) || entity.dead) { // Paper - don't pull dead players
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, entity.locY, centerZ);
+            if (searchRadius >= 0.0d && distance >= searchRadiusSquared) {
+                // With searchRadius >= 0.0d:
+                //   pulling player closest to x, y, z regardless of distance when searchRadius < 0, in keeping with previous behavior
+                // With distance >= searchRadiusSquared:
+                //   getEntities is a cube. We want a sphere, so double-check distance.
+                continue;
+            }
+            minDistance = Math.min(minDistance, distance);
+            if (distance == minDistance) {
+                retVal = (EntityHuman) entity;
+            }
+        }
+
+        return retVal;
+    }
+    /*default EntityHuman a(double d0, double d1, double d2) {
         double d3 = -1.0D;
         EntityHuman entityhuman = null;
         Iterator iterator = this.getPlayers().iterator();
@@ -113,9 +202,43 @@ public interface IEntityAccess {
         }
 
         return entityhuman;
-    }
+    }*/
+
+    default boolean isPlayerNearby(double centerX, double centerY, double centerZ, double searchRadius) {
+        if (searchRadius < 0.0d) {
+            // Keeping with previous behavior
+            return !this.getPlayers().isEmpty();
+        }
 
-    default boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        List<Entity> foundEntities = getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                centerY - searchRadius,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                centerY + searchRadius,
+                centerZ + searchRadius
+            ),
+            IEntitySelector.notSpectator()
+        );
+        if (foundEntities.isEmpty()) {
+            return false;
+        }
+
+        double searchRadiusSquared = searchRadius * searchRadius;
+        for (Entity entity : foundEntities) {
+            if (!(entity instanceof EntityHuman) || entity.dead) { // Paper - Optimize previous behavior, test if dead
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, centerY, centerZ);
+            if (distance < searchRadiusSquared) {
+                // getEntities is a cube. We want a sphere, so double-check distance.
+                return true;
+            }
+        }
+        return false;
+    }
+    /*default boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
         Iterator iterator = this.getPlayers().iterator();
 
         double d4;
@@ -137,7 +260,8 @@ public interface IEntityAccess {
         } while (d3 >= 0.0D && d4 >= d3 * d3);
 
         return true;
-    }
+    }*/
+    // Paper end
 
     @Nullable
     default EntityHuman a(PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving) {
-- 
2.22.0.windows.1

