From 9f5e59128e7e24eb6333e43467680c26d1b08bd5 Mon Sep 17 00:00:00 2001
From: egg82 <eggys82@gmail.com>
Date: Sat, 10 Aug 2019 13:35:03 -0600
Subject: [PATCH] Optimize player search methods

This patch optimizes world searches for players, and hooks methods
that can be optimized further in future patches.

In regards to open issues, it should close #1289

The optimizations are as follows:
  1. Short-circuit edge cases
  2. Optimize methods in general
  3. Utilize getEntities method which can be optimized in future patches

diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index c950139c0..ba0d175ba 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -206,6 +206,7 @@ public class AxisAlignedBB {
         return this.e(vec3d.x, vec3d.y, vec3d.z);
     }
 
+    public final boolean contains(double d0, double d1, double d2) { return e(d0, d1, d2); } // Paper - OBFHELPER
     public boolean e(double d0, double d1, double d2) {
         return d0 >= this.minX && d0 < this.maxX && d1 >= this.minY && d1 < this.maxY && d2 >= this.minZ && d2 < this.maxZ;
     }
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index e8def7f81..0c782d5f5 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1391,6 +1391,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return MathHelper.c(f * f + f1 * f1 + f2 * f2);
     }
 
+    public double getDistanceSquared(double centerX, double centerY, double centerZ) { return e(centerX, centerY, centerZ); } // Paper - OBFHELPER
     public double e(double d0, double d1, double d2) {
         double d3 = this.locX - d0;
         double d4 = this.locY - d1;
diff --git a/src/main/java/net/minecraft/server/IEntityAccess.java b/src/main/java/net/minecraft/server/IEntityAccess.java
index dca18afdb..5afcc842d 100644
--- a/src/main/java/net/minecraft/server/IEntityAccess.java
+++ b/src/main/java/net/minecraft/server/IEntityAccess.java
@@ -60,7 +60,49 @@ public interface IEntityAccess {
     }
 
     @Nullable
-    default EntityHuman a(double d0, double d1, double d2, double d3, @Nullable Predicate<Entity> predicate) {
+    // Paper start - optimize method
+    default EntityHuman a(double centerX, double centerY, double centerZ, double searchRadius, @Nullable Predicate<Entity> predicate) {
+        List<EntityHuman> foundEntities = searchRadius < 0.0d ? getAllPlayers(predicate)
+            : filterPlayers(getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                centerY - searchRadius,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                centerY + searchRadius,
+                centerZ + searchRadius
+            ),
+            predicate
+        ));
+        if (foundEntities.isEmpty()) {
+            return null;
+        }
+
+        EntityHuman retVal = null;
+        double minDistance = Double.MAX_VALUE;
+        double searchRadiusSquared = searchRadius * searchRadius;
+
+        for (EntityHuman entity : foundEntities) {
+            if (entity == null || entity.dead) { // Paper - don't pull dead players
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, centerY, centerZ);
+            if (searchRadius >= 0.0d && distance >= searchRadiusSquared) {
+                // With searchRadius >= 0.0d:
+                //   pulling player closest to x, y, z regardless of distance when searchRadius < 0, in keeping with previous behavior
+                // With distance >= searchRadiusSquared:
+                //   getEntities is a cube. We want a sphere, so double-check distance.
+                continue;
+            }
+            minDistance = Math.min(minDistance, distance);
+            if (distance == minDistance) {
+                retVal = entity;
+            }
+        }
+
+        return retVal;
+    }
+    /*default EntityHuman a(double d0, double d1, double d2, double d3, @Nullable Predicate<Entity> predicate) {
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
         Iterator iterator = this.getPlayers().iterator();
@@ -79,7 +121,24 @@ public interface IEntityAccess {
         }
 
         return entityhuman;
+    }*/
+
+    default List<EntityHuman> getAllPlayers(@Nullable Predicate<? super Entity> predicate) {
+        List<EntityHuman> retVal = Lists.newArrayList(this.getPlayers());
+        if (predicate != null) {
+            retVal.removeIf(predicate);
+        }
+        return retVal;
+    }
+
+    default List<EntityHuman> filterPlayers(@Nullable List<? extends Entity> entities) {
+        if (entities == null || entities.isEmpty()) {
+            return Lists.newArrayList();
+        }
+
+        return Lists.transform(entities, v -> v instanceof EntityHuman ? (EntityHuman) v : null);
     }
+    // Paper end
 
     @Nullable
     default EntityHuman findNearbyPlayer(Entity entity, double d0) {
@@ -94,7 +153,49 @@ public interface IEntityAccess {
     }
 
     @Nullable
-    default EntityHuman a(double d0, double d1, double d2) {
+    // Paper start - optimize methods
+    default EntityHuman a(double centerX, double centerZ, double searchRadius) {
+        List<EntityHuman> foundEntities = searchRadius < 0.0d ? getAllPlayers(IEntitySelector.notSpectator())
+            : filterPlayers(getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                Double.MIN_VALUE,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                Double.MAX_VALUE,
+                centerZ + searchRadius
+            ),
+            IEntitySelector.notSpectator()
+        ));
+        if (foundEntities.isEmpty()) {
+            return null;
+        }
+
+        EntityHuman retVal = null;
+        double minDistance = Double.MAX_VALUE;
+        double searchRadiusSquared = searchRadius * searchRadius;
+
+        for (EntityHuman entity : foundEntities) {
+            if (entity == null || entity.dead) { // Paper - don't pull dead players
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, entity.locY, centerZ);
+            if (searchRadius >= 0.0d && distance >= searchRadiusSquared) {
+                // With searchRadius >= 0.0d:
+                //   pulling player closest to x, y, z regardless of distance when searchRadius < 0, in keeping with previous behavior
+                // With distance >= searchRadiusSquared:
+                //   getEntities is a cube. We want a sphere, so double-check distance.
+                continue;
+            }
+            minDistance = Math.min(minDistance, distance);
+            if (distance == minDistance) {
+                retVal = entity;
+            }
+        }
+
+        return retVal;
+    }
+    /*default EntityHuman a(double d0, double d1, double d2) {
         double d3 = -1.0D;
         EntityHuman entityhuman = null;
         Iterator iterator = this.getPlayers().iterator();
@@ -113,9 +214,39 @@ public interface IEntityAccess {
         }
 
         return entityhuman;
-    }
+    }*/
+
+    default boolean isPlayerNearby(double centerX, double centerY, double centerZ, double searchRadius) {
+        List<EntityHuman> foundEntities = searchRadius < 0.0d ? getAllPlayers(IEntitySelector.notSpectator())
+            : filterPlayers(getEntities(null,
+            new AxisAlignedBB(
+                centerX - searchRadius,
+                centerY - searchRadius,
+                centerZ - searchRadius,
+                centerX + searchRadius,
+                centerY + searchRadius,
+                centerZ + searchRadius
+            ),
+            IEntitySelector.notSpectator()
+        ));
+        if (foundEntities.isEmpty()) {
+            return false;
+        }
 
-    default boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        double searchRadiusSquared = searchRadius * searchRadius;
+        for (EntityHuman entity : foundEntities) {
+            if (entity == null || !IEntitySelector.isAlive().test(entity)) {
+                continue;
+            }
+            double distance = entity.getDistanceSquared(centerX, centerY, centerZ);
+            if (distance < searchRadiusSquared) {
+                // getEntities is a cube. We want a sphere, so double-check distance.
+                return true;
+            }
+        }
+        return false;
+    }
+    /*default boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
         Iterator iterator = this.getPlayers().iterator();
 
         double d4;
@@ -137,7 +268,8 @@ public interface IEntityAccess {
         } while (d3 >= 0.0D && d4 >= d3 * d3);
 
         return true;
-    }
+    }*/
+    // Paper end
 
     @Nullable
     default EntityHuman a(PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving) {
diff --git a/src/main/java/net/minecraft/server/IEntitySelector.java b/src/main/java/net/minecraft/server/IEntitySelector.java
index 56739e6ed..6c06faa96 100644
--- a/src/main/java/net/minecraft/server/IEntitySelector.java
+++ b/src/main/java/net/minecraft/server/IEntitySelector.java
@@ -7,6 +7,7 @@ import javax.annotation.Nullable;
 public final class IEntitySelector {
 
     public static final Predicate<Entity> a = Entity::isAlive;
+    public static Predicate<EntityLiving> isAlive() { return b; } // Paper - OBFHELPER
     public static final Predicate<EntityLiving> b = EntityLiving::isAlive;
     public static final Predicate<Entity> c = (entity) -> {
         return entity.isAlive() && !entity.isVehicle() && !entity.isPassenger();
-- 
2.22.0.windows.1

